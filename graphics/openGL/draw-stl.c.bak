#include<stdio.h>
#include<stdlib.h>
#include<GL/glew.h>
#include<GLFW/glfw3.h>
#include<time.h>

#include"shader.c"
#include<stl.h> // Custom code to read STL files

unsigned int width = 500;
unsigned int height = 500;

float model[] = {
	0.2, 0.0, 0.0, 0.0,
	0.0, 0.2, 0.0, 0.0,
	0.0, 0.0, 0.2, 0.0,
	0.0, 0.0, 0.0, 1.0
};
float view[] = {
	1.0, 0.0, 0.0, 0.0,
	0.0, 1.0, 0.0, 0.0,
	0.0, 0.0, 1.0, 0.0,
	0.0, 0.0, 0.0, 1.0
};
float projection[] = {
	1.0, 0.0, 0.0, 0.0,
	0.0, 1.0, 0.0, 0.0,
	0.0, 0.0, 1.0, 0.0,
	0.0, 0.0, 0.0, 1.0
};

float randf(){
	return (float) rand() / (float)RAND_MAX;
}

float *flatten_stl_triangles(struct triangle *tris, const unsigned int count){
	float *ret = malloc(9 * count * sizeof(*ret));
	if(ret == NULL) return NULL;

	for(unsigned int i = 0;i < count;i++){
		ret[9*i] = tris[i].verts[0].x;
		ret[9*i + 1] = tris[i].verts[0].y;
		ret[9*i + 2] = tris[i].verts[0].z;

		ret[9*i + 3] = tris[i].verts[1].x;
		ret[9*i + 4] = tris[i].verts[1].y;
		ret[9*i + 5] = tris[i].verts[1].z;

		ret[9*i + 6] = tris[i].verts[2].x;
		ret[9*i + 7] = tris[i].verts[2].y;
		ret[9*i + 8] = tris[i].verts[2].z;
	}

	return ret;
}

int main(int argc, char *argv[]){
	srand(time(0));
	// Pick file
	const int num_files = 1;
	char *filename = "/home/chris/Documents/freeCAD/box-thing.stl";

	/*	Window setup
	*/
	printf("Init GLFW\n");
	glewExperimental = GL_TRUE;
	if(!glfwInit()){
		fprintf(stderr, "GLFW init failed.\n");
		return -1;
	}

	glfwWindowHint(GLFW_SAMPLES, 4);
	glfwWindowHint(GLFW_CONTEXT_VERSION_MAJOR, 3);
	glfwWindowHint(GLFW_CONTEXT_VERSION_MINOR, 3);
	glfwWindowHint(GLFW_OPENGL_PROFILE, GLFW_OPENGL_CORE_PROFILE);

	printf("Creating window..\n");
	GLFWwindow *window = glfwCreateWindow(width, height, filename, NULL, NULL);
	if(window == NULL){
		fprintf(stderr, "Window creation failed\n");
		glfwTerminate();
		return -1;
	}

	glfwMakeContextCurrent(window);
	glfwSetInputMode(window, GLFW_STICKY_KEYS, GLFW_TRUE);

	/*	GL setup
	*/
	if(glewInit() != GLEW_OK){
		fprintf(stderr, "Glew failed.\n");
		glfwTerminate();
		return -1;
	}

	/*	Get STL data
	*/
	printf("Fetching data..\n");
	size_t sizes[num_files];
	unsigned int num_triangles[num_files];
	float *triangles[num_files];
	struct triangle *tris;
	for(int i = 0;i < num_files;i++){
		tris = stl_read_triangles_file(filename, num_triangles + i);
		if(tris == NULL){
			fprintf(stderr, "Read error.\n");
			glfwTerminate();
			return -2;
		}
		triangles[i] = flatten_stl_triangles(tris, num_triangles[i]);
		if(triangles[i] == NULL){
			fprintf(stderr, "Flatten error.\n");
			glfwTerminate();
			return -2;
		}
		sizes[i] = 9 * num_triangles[i] * sizeof(**triangles);
		printf("Got %d triangles\n", num_triangles[i]);

		free(tris);
	}

	/*	Testing
	*/

	float high = triangles[0][0];
	for(int i = 0;i < 9*num_triangles[0];i++) if(fabs(triangles[0][i]) > high) high = fabs(triangles[0][i]);
	printf("High: %f\tinv: %f\n", high, 1.0 / high);

	/*num_triangles[0] = 6;
	sizes[0] = 9 * num_triangles[0] * sizeof(**triangles);

	const int base = 0;
	for(int i = 0;i < num_triangles[0];i++){
		float xoffset = 10*randf() - 5;
		float yoffset = 10*randf() - 5;
		triangles[0][9*i + base] = -1.0 + xoffset;
		triangles[0][9*i + base+1] = -1.0 + yoffset;
		triangles[0][9*i + base+2] = 0;
		triangles[0][9*i + base+3] = 1.0 + xoffset;
		triangles[0][9*i + base+4] = -1.0 + yoffset;
		triangles[0][9*i + base+5] = 0;
		triangles[0][9*i + base+6] = 0 + xoffset;
		triangles[0][9*i + base+7] = 1.0 + yoffset;
		triangles[0][9*i + base+8] = 0;
	}

	unsigned char *test = (unsigned char *)triangles[0];
	printf("%p\n", triangles[0]);
	for(int i = 0;i < sizes[0];i += 4){
		printf("[%d]: %f\n", i, *(float *)(test + i));
	}*/

	/*	Attempt to make expandable VAO usage
	*/
	GLuint *VAOs = malloc(num_files * sizeof(*VAOs));
	if(VAOs == NULL){
		fprintf(stderr, "VAO alloc failed\n");
		glfwTerminate();
		return -1;
	}
	glGenVertexArrays(num_files, VAOs);

	/*	Load data
	*/
	printf("Loding data..\n");

	const float color_red[] = {1.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 1.0};
	size_t color_size = sizeof(color_red);
	printf("Color size: %lu\n", color_size);

	GLuint vertex_buffers[num_files];
	glGenBuffers(num_files, vertex_buffers);
	GLuint color_buffers[num_files];
	glGenBuffers(num_files, color_buffers);

	for(int i = 0;i < num_files;++i){
		printf("Triangles size: %d\n", sizes[i]);
		glBindVertexArray(VAOs[i]);

		// If more than one buffer, consider using glBindVertexBuffer() & glVertexAttribFormat() (requires GL 4.3)
		glBindBuffer(GL_ARRAY_BUFFER, vertex_buffers[i]);
		glBufferData(GL_ARRAY_BUFFER, sizes[i], &triangles[i][0], GL_DYNAMIC_DRAW);
		glVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, 0, 0);
		glVertexAttribDivisor(0, 1);
		glEnableVertexAttribArray(0);

		// Colors
		glBindBuffer(GL_ARRAY_BUFFER, color_buffers[i]);
		glBufferData(GL_ARRAY_BUFFER, color_size, color_red, GL_STATIC_DRAW);

		glVertexAttribPointer(1, 3, GL_FLOAT, GL_FALSE, 0, 0);
		glVertexAttribDivisor(1, 0);
		glEnableVertexAttribArray(1);
	}

	/*	Program and shader init
	*/
	GLuint programID = LoadShaders("simple-vshader.glsl", "simple-fshader.glsl");
	if(!programID){
		fprintf(stderr, "Shaders failed to load\n");
		glfwTerminate();
		return -1;
	}
	glUseProgram(programID);

	GLuint uniform_model = glGetUniformLocation(programID, "model");
	GLuint uniform_view = glGetUniformLocation(programID, "view");
	GLuint uniform_projection = glGetUniformLocation(programID, "projection");

	perspective(projection, M_PI/4.0, (float)width / (float)height, 1, 100.0f);
	lookAt(view, 0,0,20, 0,0,0, 0,1,0);

	glUniformMatrix4fv(uniform_model, 1, GL_TRUE, model);
	glUniformMatrix4fv(uniform_view, 1, GL_TRUE, view);
	glUniformMatrix4fv(uniform_projection, 1, GL_TRUE, projection);

	/*	Event loop
	*/
	register unsigned long frame = 0;

	glEnable(GL_DEPTH_TEST);
	glDepthFunc(GL_LESS);
	do{
		++frame;
		glClearColor(0, 0.2, 0, 1);
		glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);

		lookAt(view, 20*cos(frame*M_PI/180.0),2,20*sin(frame*M_PI/180.0), 0,0,0, 0,1,0);
		glUniformMatrix4fv(uniform_view, 1, GL_TRUE, view);

		/*	Draw stuff
		*/
		for(int i = 0;i < num_files;i++){
			glBindVertexArray(VAOs[i]);

			glDrawArraysInstanced(GL_TRIANGLES, 0, 3, num_triangles[i]);
			//glDrawArrays(GL_TRIANGLES, 0, num_triangles[i]*3);
		}

		glfwPollEvents();
		glfwSwapBuffers(window);
	}while(glfwGetKey(window, GLFW_KEY_ESCAPE) != GLFW_PRESS && !glfwWindowShouldClose(window));

	// Cleanup
	glDeleteProgram(programID);
	glDeleteBuffers(num_files, color_buffers);
	glDeleteBuffers(num_files, vertex_buffers);
	for(int i = 0;i < num_files;i++) free(triangles[i]);
	glDeleteVertexArrays(num_files, VAOs);
	free(VAOs);
	glfwDestroyWindow(window);
	glfwTerminate();

	return 0;
}
